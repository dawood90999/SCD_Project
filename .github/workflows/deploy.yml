
name: Build and Deploy MERN App to Minikube

on:
  push:
    branches:
      - testing
      

jobs:
  build-deploy:
    runs-on: self-hosted

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Start Minikube
        shell: pwsh
        run: |
          minikube start
          minikube status

      - name: Start Minikube Tunnel
        shell: pwsh
        run: |
          Write-Output "Starting minikube tunnel in the background..."
          Start-Process -FilePath "minikube" -ArgumentList "tunnel" -NoNewWindow -RedirectStandardOutput "tunnel.log" -RedirectStandardError "tunnel.err"
          Start-Sleep -Seconds 10  # Wait for tunnel to initialize
          Get-Content tunnel.log  # Display tunnel output for debugging

      - name: Set up Docker to use Minikube's environment
        shell: pwsh
        run: |
          Write-Output "Configuring Docker to use Minikube's daemon..."
          minikube -p minikube docker-env --shell powershell | Invoke-Expression

      - name: Build Frontend Docker image
        shell: pwsh
        run: |
          cd frontend
          docker build -t dawoodhussain/mern-frontend:latest .

      - name: Build Backend Docker image
        shell: pwsh
        run: |
          cd backend
          docker build -t dawoodhussain/mern-backend:latest .

      - name: Login to Docker Hub
        shell: pwsh
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
        run: |
          echo "$env:DOCKER_PASSWORD" | docker login -u "$env:DOCKER_USERNAME" --password-stdin

      - name: Push Frontend image to Docker Hub
        shell: pwsh
        run: docker push dawoodhussain/mern-frontend:latest

      - name: Push Backend image to Docker Hub
        shell: pwsh
        run: docker push dawoodhussain/mern-backend:latest

      - name: Deploy to Minikube
        shell: pwsh
        run: |
          kubectl create namespace mern-app --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -f k8s/mongodb.yaml
          kubectl apply -f k8s/backend.yaml
          kubectl apply -f k8s/frontend.yaml
          kubectl rollout status deployment/mongodb -n mern-app
          kubectl rollout status deployment/backend -n mern-app
          kubectl rollout status deployment/frontend -n mern-app

      - name: Verify deployment
        shell: pwsh
        run: |
          kubectl get pods -n mern-app
          kubectl get svc -n mern-app

      - name: Get Frontend URL
        shell: pwsh
        run: |
          $ip = minikube ip
          $port = kubectl get svc frontend -n mern-app -o=jsonpath="{.spec.ports[0].nodePort}"
          $frontendUrl = "http://${ip}:${port}"
          Write-Output "✅ Frontend is accessible at: $frontendUrl"
          # Verify frontend accessibility
          try {
            $response = Invoke-WebRequest -Uri $frontendUrl -UseBasicParsing -TimeoutSec 10
            if ($response.StatusCode -eq 200) {
              Write-Output "✅ Frontend responded with status 200"
            } else {
              Write-Output "⚠️ Frontend responded with status: $($response.StatusCode)"
            }
          } catch {
            Write-Output "❌ Failed to access frontend at: $frontendUrl"
            Write-Output $_.Exception.Message
            exit 1
          }

      - name: Verify Backend Accessibility
        shell: pwsh
        run: |
          Write-Output "Verifying backend accessibility..."
          $backendUrl = "http://127.0.0.1:5000/api/"
          try {
            $response = Invoke-WebRequest -Uri $backendUrl -UseBasicParsing -TimeoutSec 10
            if ($response.StatusCode -eq 200) {
              Write-Output "✅ Backend is accessible at: $backendUrl"
            } else {
              Write-Output "⚠️ Backend responded with status auparavant: $($response.StatusCode)"
            }
          } catch {
            Write-Output "❌ Failed to access backend at: $backendUrl"
            Write-Output $_.Exception.Message
            exit 1
          }

      - name: Cleanup Minikube Tunnel
        shell: pwsh
        if: always()
        run: |
          Write-Output "Stopping minikube tunnel..."
          Stop-Process -Name "minikube" -Force -ErrorAction SilentlyContinue
          Get-Content tunnel.log  # Display final tunnel output for debugging
          Get-Content tunnel.err  # Display tunnel errors, if any
```

### Key Changes and Explanations
1. **Replaced `minikube service --url`**:
   - Removed `$frontendUrl = minikube service frontend -n mern-app --url`, which requires an open terminal.
   - Reverted to your original approach:
     ```powershell
     $ip = minikube ip
     $port = kubectl get svc frontend -n mern-app -o=jsonpath="{.spec.ports[0].nodePort}"
     $frontendUrl = "http://${ip}:${port}"
     ```
     This constructs the frontend URL (e.g., `http://<minikube-ip>:30007`) without needing a tunnel for the frontend (`NodePort` doesn’t require `minikube tunnel`).

2. **Added Frontend Accessibility Check**:
   - Included an `Invoke-WebRequest` to test the frontend URL (`http://<minikube-ip>:30007`).
   - If the request fails or returns a non-200 status, the workflow fails with an error message.
   - Added a `TimeoutSec` of 10 seconds to avoid hanging if the frontend is unresponsive.

3. **Kept `minikube tunnel` for Backend**:
   - The `Start Minikube Tunnel` step runs `minikube tunnel` in the background to make the `backend` service (`LoadBalancer`) accessible at `http://127.0.0.1:5000/api/`.
   - The `Start-Sleep -Seconds 10` ensures the tunnel is active before proceeding.
   - The `Verify Backend Accessibility` step tests `http://127.0.0.1:5000/api/` to confirm the backend is reachable.

4. **Improved Cleanup**:
   - The `Cleanup Minikube Tunnel` step stops the `minikube tunnel` process and displays `tunnel.log` and `tunnel.err` for debugging.
   - Uses `-ErrorAction SilentlyContinue` to avoid errors if the process is already stopped.

5. **Error Handling**:
   - Both `Get Frontend URL` and `Verify Backend Accessibility` steps use `try/catch` blocks to handle network errors gracefully and provide detailed error messages.
   - The workflow fails (`exit 1`) if either the frontend or backend is inaccessible, ensuring you’re alerted to issues.

### Assumptions
- Your `frontend.yaml` has `VITE_REACT_APP_API_URL` set to `http://127.0.0.1:5000/api/`, as configured for **Option 2 (Minikube Tunnel)**.
- The `backend` service is `LoadBalancer`, exposing port `5000`, and responds to `http://127.0.0.1:5000/api/` with a `200 OK` or valid response.
- The `frontend` service is `NodePort` with `nodePort: 30007` and serves a webpage at `http://<minikube-ip>:30007`.
- The self-hosted runner is on Windows, using the Docker driver for Minikube, and has `minikube`, `kubectl`, and `docker` installed.
- The backend handles CORS for requests from `http://<minikube-ip>:30007`. If not, you may need to update the `dawoodhussain/mern-backend` image with CORS middleware (e.g., `cors` in Express).

### Testing the Workflow
1. **Update Your Repository**:
   - Replace the existing `.github/workflows/build-deploy.yml` (or equivalent) with the updated workflow YAML above.
   - Ensure your Kubernetes manifests (`k8s/*.yaml`) are correct, especially:
     - `frontend.yaml`: `VITE_REACT_APP_API_URL: "http://127.0.0.1:5000/api/"`
     - `backend.yaml`: `type: LoadBalancer` for the service
   - Commit and push the changes:
     ```bash
     git add .
     git commit -m "Update GitHub Actions to fix minikube service --url issue"
     git push origin main
     ```

2. **Monitor the Workflow**:
   - Go to your GitHub repository → Actions tab.
   - Watch the `Build and Deploy MERN App to Minikube` workflow run.
   - Check the output for:
     - `Get Frontend URL`: Should show `http://<minikube-ip>:30007` and confirm a `200 OK` response.
     - `Verify Backend Accessibility`: Should confirm `http://127.0.0.1:5000/api/` is accessible.
     - `tunnel.log` and `tunnel.err` in case of tunnel-related issues.

3. **Access the Application**:
   - After the workflow succeeds, note the frontend URL from the `Get Frontend URL` step (e.g., `http://<minikube-ip>:30007`).
   - Open the URL in a browser to verify the frontend loads.
   - If you need to test the backend manually, ensure `minikube tunnel` is running on the self-hosted runner:
     ```bash
     minikube tunnel
     ```
   - Test the backend:
     ```bash
     curl http://127.0.0.1:5000/api/
     ```

### Troubleshooting
If the workflow fails or the application isn’t accessible:
- **Minikube Tunnel Failure**:
  - Check `tunnel.log` and `tunnel.err` in the workflow logs (`Start Minikube Tunnel` and `Cleanup Minikube Tunnel` steps).
  - Ensure no other `minikube tunnel` processes are running on the self-hosted runner:
    ```bash
    ps aux | grep minikube
    kill <pid>
    ```
  - Verify the backend service has an `EXTERNAL-IP`:
    ```bash
    kubectl get svc -n mern-app
    ```

- **Frontend or Backend Inaccessibility**:
  - If the `Get Frontend URL` or `Verify Backend Accessibility` steps fail, check the error messages in the workflow logs.
  - Inspect pod logs:
    ```bash
    kubectl logs -n mern-app <frontend-pod-name>
    kubectl logs -n mern-app <backend-pod-name>
    ```
  - Verify pod status:
    ```bash
    kubectl get pods -n mern-app
    kubectl describe pod -n mern-app <pod-name>
    ```

- **CORS Issues**:
  - If the frontend loads but fails to fetch data from the backend (e.g., `ERR_NETWORK` or CORS errors in the browser), ensure the backend allows CORS for `http://<minikube-ip>:30007`. Example for Express:
    ```javascript
    const cors = require('cors');
    app.use(cors({ origin: 'http://<minikube-ip>:30007' }));
    ```
    Rebuild and push the `dawoodhussain/mern-backend` image, then redeploy:
    ```bash
    kubectl rollout restart deployment/backend -n mern-app
    ```

- **Docker Driver Issues**:
  - If Minikube or the Docker driver misbehaves, try restarting Minikube:
    ```bash
    minikube stop
    minikube start
    ```
  - Ensure the self-hosted runner has sufficient resources (CPU, memory) for Minikube.

### Notes on Persistent Access
- **GitHub Actions Limitation**: The workflow cannot keep `minikube tunnel` or a frontend service tunnel running after completion, as GitHub Actions jobs are ephemeral. The `Cleanup Minikube Tunnel` step ensures resources are released.
- **Persistent Access**: If you need the application to remain accessible (e.g., for testing outside the workflow), run `minikube tunnel` manually on the self-hosted runner and access `http://<minikube-ip>:30007`. Alternatively, consider:
  - Deploying to a persistent Minikube cluster or a cloud-based Kubernetes cluster.
  - Using **Option 3 (Ingress)** for a domain-based setup (`mern-app.local`), which is more robust. Let me know if you want to switch to this.

### Additional Recommendations
- **Error Handling**: The workflow now fails explicitly if the frontend or backend is inaccessible, but you could add retries or more detailed diagnostics if needed.
- **Logging**: Consider adding more `kubectl describe` commands to capture service or pod details on failure.
- **Ingress Alternative**: If the Docker driver’s terminal requirement becomes a persistent issue, switching to an Ingress-based setup avoids `minikube tunnel` for both services. I can provide an updated workflow and `ingress.yaml` if you’re interested.

If you encounter issues with the updated workflow or need further tweaks (e.g., handling specific backend paths, adding Ingress, or debugging failures), please share:
- The full workflow logs from GitHub Actions.
- Output of:
  ```bash
  minikube ip
  kubectl get svc -n mern-app
  kubectl get pods -n mern-app
  ```
- Browser errors (from Developer Tools → Network or Console).
- Contents of `tunnel.log` and `tunnel.err` from the workflow.

This revised workflow should resolve the terminal issue and ensure your MERN app is deployed and verified correctly in Minikube.
